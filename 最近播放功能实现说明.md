#***REMOVED***最近播放功能实现说明

##***REMOVED***功能概述
-***REMOVED***在“最近播放”页面实时展示用户最近播放的歌曲，最新记录置顶。
-***REMOVED***记录播放时间、播放时长、播放进度，支持移除与清空。
-***REMOVED***与主流音乐网站一致：播放成功即入列；进度变化将记录上移。

##***REMOVED***数据库设计
-***REMOVED***表名：`user_recent_play`
-***REMOVED***关键字段：
***REMOVED******REMOVED***-***REMOVED***`user_id`、`music_id`（联合唯一，避免重复）
***REMOVED******REMOVED***-***REMOVED***`play_time`（最近播放时间，倒序）
***REMOVED******REMOVED***-***REMOVED***`play_duration`（秒）
***REMOVED******REMOVED***-***REMOVED***`play_progress`（百分比，0-100）
-***REMOVED***索引：`idx_user_play_time(user_id,***REMOVED***play_time***REMOVED***DESC)`
-***REMOVED***保留策略：最多100条，超出自动删除最旧记录

SQL***REMOVED***位置：`springboot/src/main/resources/sql/user_recent_play.sql`

##***REMOVED***后端实现
-***REMOVED***Controller：`UserRecentPlayController`
***REMOVED******REMOVED***-***REMOVED***`POST***REMOVED***/api/recent-play/record`：插入或更新并刷新***REMOVED***`play_time`
***REMOVED******REMOVED***-***REMOVED***`PUT***REMOVED***/api/recent-play/progress`：更新进度与时长，并刷新***REMOVED***`play_time`
***REMOVED******REMOVED***-***REMOVED***`GET***REMOVED***/api/recent-play/user/{userId}`：按***REMOVED***`play_time`***REMOVED***倒序查询
***REMOVED******REMOVED***-***REMOVED***`DELETE***REMOVED***/api/recent-play/user/{userId}/music/{musicId}`：移除单条
***REMOVED******REMOVED***-***REMOVED***`DELETE***REMOVED***/api/recent-play/user/{userId}/clear`：清空
-***REMOVED***Service：`UserRecentPlayService`
***REMOVED******REMOVED***-***REMOVED***`recordPlay(...)`***REMOVED***使用***REMOVED***`ON***REMOVED***DUPLICATE***REMOVED***KEY***REMOVED***UPDATE`***REMOVED***去重并更新时间
***REMOVED******REMOVED***-***REMOVED***`updatePlayProgress(...)`***REMOVED***更新进度并更新时间
***REMOVED******REMOVED***-***REMOVED***`deleteOldRecords(userId,***REMOVED***keep=100)`***REMOVED***超限清理
-***REMOVED***Mapper：`UserRecentPlayMapper`（注解SQL）

##***REMOVED***前端实现
-***REMOVED***Store：`frontend/src/stores/music.ts`
***REMOVED******REMOVED***-***REMOVED***在***REMOVED***`playMusic`***REMOVED***成功后调用***REMOVED***`recordRecentPlay(music)`
***REMOVED******REMOVED***-***REMOVED***在***REMOVED***`syncPlayProgressToDatabase`***REMOVED***成功后调用***REMOVED***`updateRecentPlayProgress(currentMusic,***REMOVED***currentTime,***REMOVED***progress)`
***REMOVED******REMOVED***-***REMOVED***新增事件：
***REMOVED******REMOVED******REMOVED******REMOVED***-***REMOVED***`addRecentPlayListener(listener)`、`removeRecentPlayListener(listener)`
***REMOVED******REMOVED******REMOVED******REMOVED***-***REMOVED***`notifyRecentPlayListeners({***REMOVED***type:***REMOVED***'record'***REMOVED***|***REMOVED***'progress',***REMOVED***music,***REMOVED***playDuration,***REMOVED***playProgress***REMOVED***})`
-***REMOVED***页面：`frontend/src/views/Recent.vue`
***REMOVED******REMOVED***-***REMOVED***首次挂载调用***REMOVED***`GET***REMOVED***/api/recent-play/user/{userId}`***REMOVED***加载列表
***REMOVED******REMOVED***-***REMOVED***订阅***REMOVED***store***REMOVED***的最近播放事件进行“增量更新”：
***REMOVED******REMOVED******REMOVED******REMOVED***-***REMOVED***`record`：若已存在则移除再***REMOVED***`unshift`***REMOVED***置顶；不存在则构造一条并置顶
***REMOVED******REMOVED******REMOVED******REMOVED***-***REMOVED***`progress`：更新该项进度与时间，并将该项置顶
***REMOVED******REMOVED***-***REMOVED***操作按键与***REMOVED***`Search.vue`***REMOVED***保持一致（播放/加入队列/下载/移除）

##***REMOVED***为什么起初不会实时更新？
-***REMOVED***最初仅在***REMOVED***`Recent.vue`***REMOVED***的***REMOVED***`onMounted`***REMOVED***时拉取一次接口数据，没有任何订阅或通知机制，导致播放后页面不感知变化，必须手动刷新。

##***REMOVED***我是怎么实现“实时更新”的？
-***REMOVED***在***REMOVED***`music.ts`***REMOVED***中新增“最近播放事件”总线：

```12:20:frontend/src/stores/music.ts
***REMOVED******REMOVED***//***REMOVED***最近播放变化监听器（携带负载，方便前端增量更新）
***REMOVED******REMOVED***type***REMOVED***RecentPlayEvent***REMOVED***=***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***type:***REMOVED***'record'***REMOVED***|***REMOVED***'progress'
***REMOVED******REMOVED******REMOVED******REMOVED***music?:***REMOVED***Music
***REMOVED******REMOVED******REMOVED******REMOVED***playDuration?:***REMOVED***number
***REMOVED******REMOVED******REMOVED******REMOVED***playProgress?:***REMOVED***number
***REMOVED******REMOVED******REMOVED******REMOVED***playTime?:***REMOVED***number
***REMOVED******REMOVED***}
***REMOVED******REMOVED***const***REMOVED***recentPlayListeners***REMOVED***=***REMOVED***ref<Array<(event:***REMOVED***RecentPlayEvent)***REMOVED***=>***REMOVED***void>>([])
***REMOVED******REMOVED***const***REMOVED***addRecentPlayListener***REMOVED***=***REMOVED***(listener:***REMOVED***(event:***REMOVED***RecentPlayEvent)***REMOVED***=>***REMOVED***void)***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***recentPlayListeners.value.push(listener)
***REMOVED******REMOVED***}
***REMOVED******REMOVED***const***REMOVED***removeRecentPlayListener***REMOVED***=***REMOVED***(listener:***REMOVED***(event:***REMOVED***RecentPlayEvent)***REMOVED***=>***REMOVED***void)***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***const***REMOVED***index***REMOVED***=***REMOVED***recentPlayListeners.value.indexOf(listener)
***REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(index***REMOVED***>***REMOVED***-1)***REMOVED***recentPlayListeners.value.splice(index,***REMOVED***1)
***REMOVED******REMOVED***}
***REMOVED******REMOVED***const***REMOVED***notifyRecentPlayListeners***REMOVED***=***REMOVED***(event:***REMOVED***RecentPlayEvent)***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***recentPlayListeners.value.forEach(l***REMOVED***=>***REMOVED***{***REMOVED***try***REMOVED***{***REMOVED***l(event)***REMOVED***}***REMOVED***catch***REMOVED***(e)***REMOVED***{***REMOVED***console.error(e)***REMOVED***}***REMOVED***})
***REMOVED******REMOVED***}
```

-***REMOVED***在记录/更新最近播放后进行通知（带负载，避免整页重拉）：

```446:456:frontend/src/stores/music.ts
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(result.code***REMOVED***===***REMOVED***200)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***//***REMOVED***记录成功后通知：
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***notifyRecentPlayListeners({***REMOVED***type:***REMOVED***'record',***REMOVED***music***REMOVED***})
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***}
```

```480:489:frontend/src/stores/music.ts
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(result.code***REMOVED***===***REMOVED***200)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***//***REMOVED***进度更新后通知：
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***notifyRecentPlayListeners({***REMOVED***type:***REMOVED***'progress',***REMOVED***music,***REMOVED***playDuration,***REMOVED***playProgress,***REMOVED***playTime:***REMOVED***Date.now()***REMOVED***})
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***}
```

-***REMOVED***在***REMOVED***`Recent.vue`***REMOVED***中订阅并进行“增量更新”（只改当前项）：

```165:194:frontend/src/views/Recent.vue
const***REMOVED***handleRecentChange***REMOVED***=***REMOVED***async***REMOVED***(event:***REMOVED***{***REMOVED***type:***REMOVED***'record'***REMOVED***|***REMOVED***'progress';***REMOVED***music?:***REMOVED***any;***REMOVED***playDuration?:***REMOVED***number;***REMOVED***playProgress?:***REMOVED***number***REMOVED***})***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED***if***REMOVED***(event.type***REMOVED***===***REMOVED***'record'***REMOVED***&&***REMOVED***event.music)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***//***REMOVED***置顶或新建置顶
***REMOVED******REMOVED******REMOVED******REMOVED***const***REMOVED***musicId***REMOVED***=***REMOVED***event.music.id.toString()
***REMOVED******REMOVED******REMOVED******REMOVED***const***REMOVED***existIdx***REMOVED***=***REMOVED***recentPlays.value.findIndex(item***REMOVED***=>***REMOVED***item.musicId.toString()***REMOVED***===***REMOVED***musicId)
***REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(existIdx***REMOVED***>***REMOVED***-1)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***const***REMOVED***exist***REMOVED***=***REMOVED***recentPlays.value.splice(existIdx,***REMOVED***1)[0]
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***exist.playTime***REMOVED***=***REMOVED***new***REMOVED***Date().toISOString()
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***recentPlays.value.unshift(exist)
***REMOVED******REMOVED******REMOVED******REMOVED***}***REMOVED***else***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***recentPlays.value.unshift({***REMOVED***/****REMOVED***构造一条记录***REMOVED****/***REMOVED***})
***REMOVED******REMOVED******REMOVED******REMOVED***}
***REMOVED******REMOVED***}***REMOVED***else***REMOVED***if***REMOVED***(event.type***REMOVED***===***REMOVED***'progress'***REMOVED***&&***REMOVED***currentMusic.value)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***//***REMOVED***更新该项并置顶
***REMOVED******REMOVED******REMOVED******REMOVED***const***REMOVED***musicId***REMOVED***=***REMOVED***(event.music?.id***REMOVED***??***REMOVED***currentMusic.value.id).toString()
***REMOVED******REMOVED******REMOVED******REMOVED***const***REMOVED***idx***REMOVED***=***REMOVED***recentPlays.value.findIndex(item***REMOVED***=>***REMOVED***item.musicId.toString()***REMOVED***===***REMOVED***musicId)
***REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(idx***REMOVED***>***REMOVED***-1)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***const***REMOVED***item***REMOVED***=***REMOVED***recentPlays.value[idx]
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(typeof***REMOVED***event.playDuration***REMOVED***===***REMOVED***'number')***REMOVED***item.playDuration***REMOVED***=***REMOVED***event.playDuration
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(typeof***REMOVED***event.playProgress***REMOVED***===***REMOVED***'number')***REMOVED***item.playProgress***REMOVED***=***REMOVED***event.playProgress
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***item.playTime***REMOVED***=***REMOVED***new***REMOVED***Date().toISOString()
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***recentPlays.value.unshift(recentPlays.value.splice(idx,***REMOVED***1)[0])
***REMOVED******REMOVED******REMOVED******REMOVED***}
***REMOVED******REMOVED***}
}
```

##***REMOVED***为什么加了实时更新后会“刷新好几次”？
-***REMOVED***初版实时实现是在事件里直接“整页重新拉取列表”（再次请求接口并整体替换列表）。
-***REMOVED***播放时会触发多处更新（播放成功记录、进度同步防抖触发等），导致在短时间内多次重新拉取，用户观感是列表频繁闪动/跳动。

##***REMOVED***最终如何改进为真正的实时且稳定？
-***REMOVED***将“整页重拉”改为“增量更新”：
***REMOVED******REMOVED***-***REMOVED***record：只对当前歌曲对应的一条记录进行“移除→unshift置顶”或“新建→置顶”，不请求接口
***REMOVED******REMOVED***-***REMOVED***progress：只更新该条记录的进度/时间并将其置顶，不请求接口
-***REMOVED***同时给通知事件增加负载（音乐、进度、时间），做到“所见即所得”的本地更新，完全避免重复请求与闪烁。

##***REMOVED***注意事项与可拓展
-***REMOVED***初次进入页面仍推荐请求接口，保证与服务器状态一致；实时变更使用本地增量同步。
-***REMOVED***若列表较长可加“最多显示N条”限制与分页/虚拟滚动优化。
-***REMOVED***需要跨端实时（多端登录）可考虑引入***REMOVED***WebSocket***REMOVED***推送。

##***REMOVED***快速排错
-***REMOVED***报错***REMOVED***“Table***REMOVED***'mymusic.user_recent_play'***REMOVED***doesn't***REMOVED***exist”：执行***REMOVED***`user_recent_play.sql`***REMOVED***初始化表。
-***REMOVED***播放后未入列：检查***REMOVED***`recordRecentPlay`***REMOVED***调用是否在***REMOVED***`playMusic`***REMOVED***成功后执行；确认后端接口返回***REMOVED***`code***REMOVED***===***REMOVED***200`。
-***REMOVED***列表频繁闪烁：确认事件回调不再调用“整页重拉”，保持增量变更。

为什么能实现监听实时更新，是用了什么api或者代码逻辑

核心不是某个“黑科技***REMOVED***API”，而是你在***REMOVED***Pinia***REMOVED***的***REMOVED***music.ts***REMOVED***里实现了一个极轻量的事件总线（发布/订阅模式，pub/sub），再配合***REMOVED***Vue***REMOVED***的响应式，完成了实时更新。
具体由三部分组成：
事件总线（自定义）：在***REMOVED***music.ts***REMOVED***里维护一个监听器数组，提供***REMOVED***add/remove/notify***REMOVED***三个方法
addRecentPlayListener(listener):***REMOVED***订阅
removeRecentPlayListener(listener):***REMOVED***退订
notifyRecentPlayListeners(event):***REMOVED***触发事件并把数据广播给所有订阅者
触发时机（在写库成功后通知）：两处后端成功返回***REMOVED***200***REMOVED***时发事件
recordRecentPlay***REMOVED***成功后，notify({***REMOVED***type:***REMOVED***'record',***REMOVED***music***REMOVED***})
updateRecentPlayProgress***REMOVED***成功后，notify({***REMOVED***type:***REMOVED***'progress',***REMOVED***music,***REMOVED***playDuration,***REMOVED***playProgress,***REMOVED***playTime***REMOVED***})
页面增量更新（Recent.vue***REMOVED***订阅并只改那一条）：onMounted***REMOVED***时订阅，事件回调里只对对应歌曲“插入/上移/更新”，不整页重拉
用到的就是：
Pinia***REMOVED***+***REMOVED***Vue***REMOVED***响应式（ref、computed）负责“数据变更会驱动视图更新”
你手写的“事件数组***REMOVED***+***REMOVED***forEach***REMOVED***调用监听器”的***REMOVED***pub/sub***REMOVED***逻辑，负责“把数据变更消息从***REMOVED***store***REMOVED***广播到页面”
没有用***REMOVED***WebSocket、没有用第三方事件库；是简单可靠的本地事件分发
为什么它“实时”？因为：
播放成功/进度同步成功后，store***REMOVED***立即***REMOVED***notify
Recent.vue***REMOVED***已经订阅了这个事件，收到后在内存里对列表做“增量变更”
Vue***REMOVED***的响应式让列表变更立刻反映到界面
为什么“不卡、不闪、不重绘整页”？因为：
事件回调里只操作一条记录（插入/上移/更新数据），不再重新请求接口替换整个数组
初次进入页面才请求一次完整列表，之后全部靠事件驱动的本地增量更新
一句话总结
使用自定义的发布/订阅（pub/sub）事件总线***REMOVED***+***REMOVED***Vue***REMOVED***响应式***REMOVED***+***REMOVED***成功后通知的触发时机，实现了“立即、增量、稳定”的实时更新。

musicStore.addRecentPlayListener(handleRecentChange***REMOVED***as***REMOVED***any)这个参数又是怎么传的，为什么每一个event都是一个recentPlayEvent，listen又是干嘛的

下面把这三点讲清楚：addRecentPlayListener***REMOVED***的参数、为什么***REMOVED***event***REMOVED***是***REMOVED***RecentPlayEvent、listener（你写成***REMOVED***listen）是干嘛的。
1)***REMOVED***addRecentPlayListener(handleRecentChange***REMOVED***as***REMOVED***any)***REMOVED***传了什么
addRecentPlayListener***REMOVED***要求“参数是一个函数”，签名是***REMOVED***(event:***REMOVED***RecentPlayEvent)***REMOVED***=>***REMOVED***void。
你传入的就是***REMOVED***Recent.vue***REMOVED***里定义的回调函数***REMOVED***handleRecentChange，它能接收一个***REMOVED***event***REMOVED***对象并做增量更新。
“as***REMOVED***any”是***REMOVED***TypeScript***REMOVED***的类型断言，简单说就是“放宽类型检查”让它通过。
代码定义：
type***REMOVED***RecentPlayEvent***REMOVED***=***REMOVED***{
***REMOVED******REMOVED***type:***REMOVED***'record'***REMOVED***|***REMOVED***'progress'
***REMOVED******REMOVED***music?:***REMOVED***Music
***REMOVED******REMOVED***playDuration?:***REMOVED***number
***REMOVED******REMOVED***playProgress?:***REMOVED***number
***REMOVED******REMOVED***playTime?:***REMOVED***number***REMOVED***//***REMOVED***ms***REMOVED***时间戳
}
const***REMOVED***addRecentPlayListener***REMOVED***=***REMOVED***(listener:***REMOVED***(event:***REMOVED***RecentPlayEvent)***REMOVED***=>***REMOVED***void)***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED***recentPlayListeners.value.push(listener)
}
订阅处：
onMounted(()***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED***loadRecentPlays()
***REMOVED******REMOVED***musicStore.addRecentPlayListener(handleRecentChange***REMOVED***as***REMOVED***any)
})
2)***REMOVED***为什么每个***REMOVED***event***REMOVED***都是一个***REMOVED***RecentPlayEvent
你在***REMOVED***store***REMOVED***里定义了事件的“结构类型”RecentPlayEvent，约定所有广播的事件都必须长这样（有***REMOVED***type***REMOVED***字段，可能带***REMOVED***music/进度等）。
这样***REMOVED***Recent.vue***REMOVED***的回调就能统一处理：看***REMOVED***type***REMOVED***===***REMOVED***'record'***REMOVED***还是***REMOVED***'progress'，再用***REMOVED***music/进度数据做增量更新。
触发广播的两处：
notifyRecentPlayListeners({***REMOVED***type:***REMOVED***'record',***REMOVED***music***REMOVED***})
notifyRecentPlayListeners({***REMOVED***type:***REMOVED***'progress',***REMOVED***music,***REMOVED***playDuration,***REMOVED***playProgress,***REMOVED***playTime:***REMOVED***Date.now()***REMOVED***})
3)***REMOVED***listener（监听器）是干嘛的
listener***REMOVED***指的就是你订阅时传入的那个回调函数（这里就是***REMOVED***handleRecentChange）。
当***REMOVED***store***REMOVED***调用***REMOVED***notifyRecentPlayListeners(event)***REMOVED***时，会把***REMOVED***event***REMOVED***依次“传给每个***REMOVED***listener”执行，这就是“通知”。
广播实现：
const***REMOVED***notifyRecentPlayListeners***REMOVED***=***REMOVED***(event:***REMOVED***RecentPlayEvent)***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED***recentPlayListeners.value.forEach(l***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***try***REMOVED***{***REMOVED***l(event)***REMOVED***}***REMOVED***catch***REMOVED***(e)***REMOVED***{***REMOVED***console.error('最近播放监听器执行错误:',***REMOVED***e)***REMOVED***}
***REMOVED******REMOVED***})
}
流程串起来就是：
Recent.vue***REMOVED***在***REMOVED***mounted***REMOVED***时“订阅”→***REMOVED***把***REMOVED***handleRecentChange***REMOVED***放进***REMOVED***listeners***REMOVED***数组；
播放成功/进度更新成功后，store***REMOVED***“广播”→***REMOVED***把***REMOVED***{***REMOVED***type,***REMOVED***music,***REMOVED***...***REMOVED***}***REMOVED***这个***REMOVED***event***REMOVED***传给数组里的每个***REMOVED***listener；
handleRecentChange***REMOVED***收到***REMOVED***event***REMOVED***→***REMOVED***只改对应一条记录（插入/上移/更新进度）→***REMOVED***Vue***REMOVED***响应式让界面立刻更新。