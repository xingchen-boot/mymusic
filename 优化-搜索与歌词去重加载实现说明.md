#***REMOVED***搜索与歌词去重加载实现说明

##***REMOVED***背景与问题
-***REMOVED***从***REMOVED***Player***REMOVED***返回主页时，Search***REMOVED***页面会重复触发同一关键词的搜索。
-***REMOVED***从***REMOVED***Footer***REMOVED***点进***REMOVED***Player***REMOVED***页面时，会重复请求当前歌曲歌词，造成不必要的网络请求和闪烁。

##***REMOVED***目标
-***REMOVED***避免重复搜索与重复拉取歌词，降低无效请求，提升页面切换流畅度。

##***REMOVED***实现概览
-***REMOVED***Search***REMOVED***去重：基于关键词的去重判定（组件层）+***REMOVED***store***REMOVED***层关键词一致返回已有结果。
-***REMOVED***歌词缓存：组件内“最近一次加载ID”快速短路***REMOVED***+***REMOVED***store***REMOVED***层全局***REMOVED***Map***REMOVED***缓存（跨页面复用）。

##***REMOVED***变更细节

###***REMOVED***1)***REMOVED***Search***REMOVED***页面去重加载
文件：`frontend/src/views/Search.vue`

-***REMOVED***路由监听：只有当新关键词与本地***REMOVED***`searchKeyword`***REMOVED***不一致时才触发***REMOVED***`performSearch`。
-***REMOVED***onMounted：首载时也进行同样的去重判定。

关键代码：
```ts
watch(()***REMOVED***=>***REMOVED***route.query.keyword,***REMOVED***(newKeyword)***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED***if***REMOVED***(newKeyword***REMOVED***&&***REMOVED***typeof***REMOVED***newKeyword***REMOVED***===***REMOVED***'string')***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(searchKeyword.value***REMOVED***!==***REMOVED***newKeyword)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***performSearch(newKeyword)
***REMOVED******REMOVED******REMOVED******REMOVED***}
***REMOVED******REMOVED***}
},***REMOVED***{***REMOVED***immediate:***REMOVED***true***REMOVED***})

onMounted(()***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED***const***REMOVED***keyword***REMOVED***=***REMOVED***route.query.keyword***REMOVED***as***REMOVED***string
***REMOVED******REMOVED***if***REMOVED***(keyword)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***if***REMOVED***(searchKeyword.value***REMOVED***!==***REMOVED***keyword)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***performSearch(keyword)
***REMOVED******REMOVED******REMOVED******REMOVED***}
***REMOVED******REMOVED***}
})
```

###***REMOVED***2)***REMOVED***Store***REMOVED***层搜索去重
文件：`frontend/src/stores/music.ts`

-***REMOVED***若***REMOVED***`searchKeyword`***REMOVED***未变且已有***REMOVED***`musicList`，直接复用结果：
```ts
if***REMOVED***(searchKeyword.value***REMOVED***===***REMOVED***keyword***REMOVED***&&***REMOVED***musicList.value.length***REMOVED***>***REMOVED***0)***REMOVED***{
***REMOVED******REMOVED***console.log('🔍***REMOVED***跳过重复搜索，使用已有结果:',***REMOVED***keyword)
***REMOVED******REMOVED***return
}
```

###***REMOVED***3)***REMOVED***Player***REMOVED***歌词加载短路
文件：`frontend/src/views/Player.vue`

-***REMOVED***使用***REMOVED***`lastLoadedMusicId`***REMOVED***记录最近一次已加载歌词的歌曲ID，相同歌曲再次进入页面时直接复用：
```ts
const***REMOVED***lastLoadedMusicId***REMOVED***=***REMOVED***ref<string***REMOVED***|***REMOVED***number***REMOVED***|***REMOVED***null>(null)

const***REMOVED***loadLyrics***REMOVED***=***REMOVED***async***REMOVED***(music:***REMOVED***any)***REMOVED***=>***REMOVED***{
***REMOVED******REMOVED***const***REMOVED***currentMusicId***REMOVED***=***REMOVED***music.id***REMOVED***||***REMOVED***music.mid
***REMOVED******REMOVED***if***REMOVED***(lastLoadedMusicId.value***REMOVED***===***REMOVED***currentMusicId***REMOVED***&&***REMOVED***lyricsLines.value.length***REMOVED***>***REMOVED***0)***REMOVED***{
***REMOVED******REMOVED******REMOVED******REMOVED***console.log('🎵***REMOVED***歌词已缓存，跳过加载:',***REMOVED***music.song)
***REMOVED******REMOVED******REMOVED******REMOVED***return
***REMOVED******REMOVED***}
***REMOVED******REMOVED***//***REMOVED***...加载逻辑
***REMOVED******REMOVED***lastLoadedMusicId.value***REMOVED***=***REMOVED***currentMusicId
}
```

###***REMOVED***4)***REMOVED***Store***REMOVED***层全局歌词缓存
文件：`frontend/src/stores/music.ts`

-***REMOVED***新增***REMOVED***`lyricsCache:***REMOVED***Map<string,***REMOVED***Lyrics|null>`***REMOVED***与***REMOVED***`lastLyricsKey`：
-***REMOVED***命中缓存直接返回，未命中才请求并写入缓存（`id:`***REMOVED***优先，其次***REMOVED***`mid:`）：
```ts
const***REMOVED***lyricsCache***REMOVED***=***REMOVED***new***REMOVED***Map<string,***REMOVED***Lyrics***REMOVED***|***REMOVED***null>()

const***REMOVED***cacheKey***REMOVED***=***REMOVED***music.id***REMOVED***?***REMOVED***`id:${music.id}`***REMOVED***:***REMOVED***`mid:${music.mid}`
if***REMOVED***(lyricsCache.has(cacheKey))***REMOVED***{
***REMOVED******REMOVED***const***REMOVED***cached***REMOVED***=***REMOVED***lyricsCache.get(cacheKey)***REMOVED***||***REMOVED***null
***REMOVED******REMOVED***currentLyrics.value***REMOVED***=***REMOVED***cached
***REMOVED******REMOVED***return***REMOVED***cached
}

const***REMOVED***response***REMOVED***=***REMOVED***await***REMOVED***axios.get(apiUrl,***REMOVED***{***REMOVED***params***REMOVED***})
if***REMOVED***(response.data.code***REMOVED***===***REMOVED***200***REMOVED***&&***REMOVED***response.data.data)***REMOVED***{
***REMOVED******REMOVED***lyricsCache.set(cacheKey,***REMOVED***response.data.data)
***REMOVED******REMOVED***currentLyrics.value***REMOVED***=***REMOVED***response.data.data
***REMOVED******REMOVED***return***REMOVED***response.data.data
}***REMOVED***else***REMOVED***{
***REMOVED******REMOVED***lyricsCache.set(cacheKey,***REMOVED***null)
***REMOVED******REMOVED***return***REMOVED***null
}
```

##***REMOVED***验证与观测
-***REMOVED***返回主页不再重复触发相同关键词搜索（Network***REMOVED***面板无重复请求）。
-***REMOVED***Footer***REMOVED***进入***REMOVED***Player***REMOVED***不再二次请求歌词（控制台出现“🗂️***REMOVED***使用歌词缓存”或“🎵***REMOVED***歌词已缓存，跳过加载”）。
-***REMOVED***页面切换更流畅，无不必要的闪烁与加载占位。

##***REMOVED***权衡与后续
-***REMOVED***歌词缓存未设置过期策略：若外部API数据变化需手动失效（可按播放/时间加TTL）。
-***REMOVED***搜索结果也可加入***REMOVED***LRU***REMOVED***缓存（关键词→结果），进一步减少来回切换的请求。
-***REMOVED***后续可在***REMOVED***`music.ts`***REMOVED***增加统一的缓存工具与统计打点，观察命中率。
